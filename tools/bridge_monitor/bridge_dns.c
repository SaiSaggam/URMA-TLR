/*****************************************************************************
* Copyright (c) 2016 Digi International Inc., All Rights Reserved
*
* This software contains proprietary and confidential information of Digi
* International Inc.  By accepting transfer of this copy, Recipient agrees
* to retain this software in confidence, to prevent disclosure to others,
* and to make no use of this software other than that for which it was
* delivered.  This is an unpublished copyrighted work of Digi International
* Inc.  Except as permitted by federal law, 17 USC 117, copying is strictly
* prohibited.
*
* Restricted Rights Legend
*
* Use, duplication, or disclosure by the Government is subject to
* restrictions set forth in sub-paragraph (c)(1)(ii) of The Rights in
* Technical Data and Computer Software clause at DFARS 252.227-7031 or
* subparagraphs (c)(1) and (2) of the Commercial Computer Software -
* Restricted Rights at 48 CFR 52.227-19, as applicable.
*
* Digi International Inc. 11001 Bren Road East, Minnetonka, MN 55343
*
*****************************************************************************/

#include "bridge_dns.h"
#include "bridge_monitor.h"
#include "bridge_monitor_init.h"
#include "bridge_monitor_log.h"
#include "bridge_monitor_config_commands.h"

#include <stdio.h>
#include <stdlib.h>

#define DNS_DIRECTORY       "/ram/var/dns"
#define MAX_DNS_NAMESERVER_SIZE     sizeof "255.255.255.255"

static char const dhcp_off_keyword[] = "off";
static char const dhcp_on_keyword[] = "on";

static inline bool dns_address_ok(char const * const dns)
{
     return (dns!=NULL) && strcmp(dns, "0.0.0.0") != 0 && strlen(dns) != 0;
}



static char const * const udhcp_nameservers_format = "/ram/var/dns/%s%zu/udhcpc_nameservers";

static bool write_dhcp_name_servers(size_t const instance, FILE * const resolv_conf)
{
    FILE * udhcp_nameservers = NULL;
    bool wrote_dhcp_name_servers_to_resolv_conf = false;
    char * nameservers_filename = NULL;
    char const nameserver_format_input[] = " %%%zus ";
    char * nameserver_format = NULL;
    char nameserver[MAX_DNS_NAMESERVER_SIZE];

    if (asprintf(&nameservers_filename, udhcp_nameservers_format, bridge_interface_name_get(), instance) == -1)
    {
        bridgemon_debug("bridge_set_dns_servers: out of memory (unable to asprintf nameservers_filename");
        goto error;
    }
    if (asprintf(&nameserver_format, nameserver_format_input, sizeof(nameserver)-1) == -1)
    {
        bridgemon_debug("bridge_set_dns_servers: out of memory (unable to asprintf nameserver_format");
        goto error;
    }

    udhcp_nameservers = fopen(nameservers_filename, "r");
    if (udhcp_nameservers != NULL)
    {
        fprintf(resolv_conf, "# Using nameservers found by DHCP\n");
        while (fscanf(udhcp_nameservers, nameserver_format, nameserver) == 1)
        {
            nameserver[sizeof(nameserver) - 1] = 0;
            fprintf(resolv_conf, "nameserver %s\n", nameserver);
            wrote_dhcp_name_servers_to_resolv_conf = true;
        }
        fclose(udhcp_nameservers);
    }

error:
    free(nameservers_filename);
    free(nameserver_format);

    return wrote_dhcp_name_servers_to_resolv_conf;
}

static pid_t read_udhcpc_pid(char const * const filename)
{
    FILE *pid_file = fopen(filename, "r");
    pid_t pid = 0;

    if (pid_file != NULL)
    {
        if (fscanf(pid_file, " %u ", &pid) != 1)
        {
            pid = 0;
        }
        fclose(pid_file);
    }

    return pid;
}

void bridge_refresh_dns_configuration(size_t const instance)
{
    bridge_context_st *context = bridge_get_context(instance);

    if (context != NULL)
    {
        char const * const dns1 = config_get_element_value(context->config, config_lan_dns1);
        char const * const dns2 = config_get_element_value(context->config, config_lan_dns2);

        bridge_set_dns_servers(instance, dns1, dns2);
    }
}

bool bridge_set_dns_servers(size_t const instance, char const * const dns1, char const * const dns2)
{
    char * filename = NULL;
    bool success = false;
    FILE * resolv_conf = NULL;
    bool dns_server_set = false;
    const char * const udhcpc_keyword = "udhcpc_search_key";

    if (asprintf(&filename, DNS_DIRECTORY"/%s%zu/resolv.conf", bridge_interface_name_get(), instance) == -1)
    {
        bridgemon_debug("bridge_set_dns_servers: out of memory (unable to asprintf filename");
        goto error;
    }
    resolv_conf = fopen(filename, "w");
    if (resolv_conf == NULL)
    {
        bridgemon_debug("bridge_set_dns_servers: Unable to create %s", filename);
        goto error;
    }
    fprintf(resolv_conf, "# This file was automatically generated by the bridge monitor\n");
    if (dns_address_ok(dns1))
    {
        fprintf(resolv_conf, "nameserver %s\t\t# %s\n", dns1, udhcpc_keyword);
        dns_server_set = true;
    }
	if (dns_address_ok(dns2))
    {
        fprintf(resolv_conf, "nameserver %s\t\t# %s\n", dns2, udhcpc_keyword);
        dns_server_set = true;
    }
    if (!dns_server_set)
    {
        if (!write_dhcp_name_servers(instance, resolv_conf))
        {
            fprintf(resolv_conf, "# No DNS servers have been set for this interface\n");
            fprintf(resolv_conf, "nameserver 8.8.8.8\n"); /* use the Google DNS server as a default*/
        }
    }
    success = true;

error:
    free(filename);
    if (resolv_conf != NULL)
    {
        fclose(resolv_conf);
    }

    return success;
}

static bool bridge_interface_set_dhcp_client(size_t const instance, bool const want_to_run_dhcp_client)
{
    char const * const pid_filename_format = "/ram/var/dns/%s%u/udhcpc.pid";
    char * pid_filename = NULL;
    bool dhcp_client_updated = false;
    bool dhcp_client_is_running;
    pid_t pid;

    if (asprintf(&pid_filename, pid_filename_format, bridge_interface_name_get(), instance) == -1)
    {
        bridgemon_debug("out of memory");
        goto done;
    }
    pid = read_udhcpc_pid(pid_filename);
    dhcp_client_is_running = pid != 0;

    if ((!dhcp_client_is_running) && (want_to_run_dhcp_client))
    {
        dhcp_client_updated = start_dhcp_client(instance, pid_filename);
    }
    else if ((dhcp_client_is_running) && (!want_to_run_dhcp_client))
    {
        stop_dhcp_client(instance, pid, pid_filename);
        bridge_refresh_dns_configuration(instance);
        dhcp_client_updated = true;
    }

done:
    free(pid_filename);
    return dhcp_client_updated;
}

bool bridge_check_if_dhcp_client_needed(size_t const instance)
{
    bool result = true;
    bridge_context_st * context = bridge_get_context(instance);

    if (context != NULL)
    {
        char const * const dhcp = config_get_element_value(context->config, config_lan_dhcp_client);

        if (strcmp(dhcp, dhcp_on_keyword) == 0)
        {
            result = bridge_interface_set_dhcp_client(instance, true);
        }
        else
        {
            bridge_refresh_dns_configuration(instance);
        }
    }

    return result;
}

bool bridge_interface_set_dhcp_client_off(size_t const instance)
{
    return bridge_interface_set_dhcp_client(instance, false);
}

bool bridge_interface_set_dhcp_client_to_desired_state(size_t const instance, char const * desired_state)
{
    bool want_to_run_dhcp_client = strcmp(desired_state, dhcp_on_keyword) == 0;

    return bridge_interface_set_dhcp_client(instance, want_to_run_dhcp_client);
}


void delete_dhcp_nameservers_file(size_t const instance)
{
    char * nameservers_file = NULL;

    if (asprintf(&nameservers_file, udhcp_nameservers_format, bridge_interface_name_get(), instance) == -1)
    {
        bridgemon_debug("out of memory");
        goto done;
    }
    if (unlink(nameservers_file) != 0)
    {
        bridgemon_debug("Error deleting udhcpc nameservers file %s", nameservers_file);
    }

done:
    free(nameservers_file);
}


