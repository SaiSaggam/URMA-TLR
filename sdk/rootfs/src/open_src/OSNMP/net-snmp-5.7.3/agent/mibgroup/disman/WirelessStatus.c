/*
 * Note: this file originally auto-generated by mib2c using
 *        $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/amit_api.h>
#include "WirelessStatus.h"

/* 
 * StatusWirelessStatus_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid StatusWirelessStatus_variables_oid[] = { 1,3,6,1,4,1,12823,3,3,9,1,2 };

/* 
 * variable4 StatusWirelessStatus_variables:
 *   this variable defines function callbacks and type return information 
 *   for the StatusWirelessStatus mib section 
 */

struct variable4 StatusWirelessStatus_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define STATUSWLANAP1WDSSETTINGLAZYMODEENABLE		1
#define STATUSWLANAP1WDSSETTINGLAZYMODEENABLE1		2
#define STATUSWLANAP1WDSSETTINGLAZYMODEENABLE2		3
#define STATUSWLANAP1WDSSETTINGLAZYMODEENABLE3		4
{STATUSWLANAP1WDSSETTINGLAZYMODEENABLE,  ASN_INTEGER,  NETSNMP_OLDAPI_RWRITE,var_StatusWirelessStatus, 2,  { 1,2 }},
{STATUSWLANAP1WDSSETTINGLAZYMODEENABLE1,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,var_StatusWirelessStatus, 2,  { 1,3 }},
{STATUSWLANAP1WDSSETTINGLAZYMODEENABLE2,  ASN_IPADDRESS,  NETSNMP_OLDAPI_RWRITE,var_StatusWirelessStatus, 2,  { 1,4 }},
{STATUSWLANAP1WDSSETTINGLAZYMODEENABLE3,  ASN_OCTET_STR,  NETSNMP_OLDAPI_RWRITE,var_StatusWirelessStatus, 2,  { 1,5 }},

};
/*    (L = length of the oidsuffix) */


/** Initializes the StatusWirelessStatus module */
void
init_StatusWirelessStatus(void)
{

    DEBUGMSGTL(("StatusWirelessStatus", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB("StatusWirelessStatus", StatusWirelessStatus_variables, variable4,
               StatusWirelessStatus_variables_oid);

    /* place any other initialization junk you need here */
}

/*
 * var_StatusWirelessStatus():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_StatusWirelessStatus(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case STATUSWLANAP1WDSSETTINGLAZYMODEENABLE:
    {
		*write_method=write_Basic1;
		read_csman(amit.csman_fd,CSID_C_SNMP_FWPATH,&long_ret,sizeof(int),CSM_R_ZERO);

        return (unsigned char *)&long_ret;
	}
	case STATUSWLANAP1WDSSETTINGLAZYMODEENABLE1:
    {
		*write_method=write_Basic2;
		amit_read_csman(TYPE_STR,CSID_C_SNMP_ENTERPRISE_OID_FULL,string);
		*var_len = strlen(string);
        return (unsigned char *)string;
	}
	case STATUSWLANAP1WDSSETTINGLAZYMODEENABLE2:
    {
		*write_method=write_Basic3;
		amit_read_csman(TYPE_IPV4,CSID_S_SNMP_SUBNETMASK,string);
		*var_len = 4;
		//*var_len = strlen(string);
        return (unsigned char *)string;
	}
	case STATUSWLANAP1WDSSETTINGLAZYMODEENABLE3:
    {
		*write_method=write_Basic4;
		amit_read_csman(TYPE_MAC,CSID_S_SNMP_MACADDRESS,string);
		//*var_len = 6;
		*var_len = strlen(string);
        return (unsigned char *)string;
	}
    default:
      ERROR_MSG("");
    }
    return NULL;
}

int
write_Basic1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned int long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to UIInternetSetupOtherSet not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)) {
              fprintf(stderr,"write to UIInternetSetupOtherSet: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
			long_ret = *(unsigned int *) var_val;
			break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
          {
			  char value[32];
			  sprintf(value,"%d",long_ret);
              amit_write_csman(TYPE_INT,CSID_C_SNMP_FWPATH,value);
              break;
          }
    }
    return SNMP_ERR_NOERROR;
}

int
write_Basic2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to UIAdvSystemMGTR069 not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(string)) {
              fprintf(stderr,"write to UIAdvSystemMGTR069: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
			//for STR/MAC data type
			memset(string,0,sizeof(string));
			strncpy(string , (char *) var_val, var_val_len);
			break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
         {
             amit_write_csman(TYPE_STR,CSID_C_SNMP_ENTERPRISE_OID_FULL,string);
             break;
		 }
    }
    return SNMP_ERR_NOERROR;
}
int
write_Basic3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_IPADDRESS) {
              fprintf(stderr, "write to UIAdvVPNIPSec not ASN_IPADDRESS\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(string)) {
              fprintf(stderr,"write to UIAdvVPNIPSec: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
			memset(string,0,sizeof(string));
			strncpy(string , (char *) var_val, 4);
			//strncpy(string , (char *) var_val, var_val_len);
			break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
		  {
			  amit_write_csman(TYPE_IPV4,CSID_S_SNMP_SUBNETMASK,string);
			  break;
		  }
    }
    return SNMP_ERR_NOERROR;
}

int
write_Basic4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned char string[SPRINT_MAX_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to UIAdvFWMACControl not \n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(string)) {
              fprintf(stderr,"write to UIAdvFWMACControl: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
			//for STR/MAC data type
			memset(string,0,sizeof(string));
			strncpy(string , (char *) var_val, var_val_len);
			break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          {
              int fd=0;
              amit_write_csman(TYPE_MAC,CSID_S_SNMP_MACADDRESS,string);
              break;
          }
    }
    return SNMP_ERR_NOERROR;
}
